'use client';

import React, { useState, useEffect } from 'react';
import EnhancedGlassMorphicContainerV2 from '@/components/ui/EnhancedGlassMorphicContainerV2';
import { OutlineItem, Character, SceneData } from '@/types/planning';

interface EnhancedPromptWorkflowProps {
  initialPrompt: string;
  onComplete: (scenesData: SceneData[]) => void;
}

// Steps in the planning process

// Steps in the planning process
type WorkflowStep = 
  | 'sending-to-ai' 
  | 'generating-outline' 
  | 'reviewing-outline'
  | 'editing-outline'
  | 'generating-scene-prompts'
  | 'reviewing-scene-prompts'
  | 'generating-images'
  | 'complete';

/**
 * Enhanced Prompt Workflow
 * 
 * Handles the process of:
 * 1. Sending the user's prompt to OpenAI GPT-4o
 * 2. Generating a story outline
 * 3. Allowing the user to edit/approve the outline
 * 4. Generating detailed scene prompts
 * 5. Preparing for the editor
 */
export const EnhancedPromptWorkflow: React.FC<EnhancedPromptWorkflowProps> = ({
  initialPrompt,
  onComplete
}) => {
  
  // Workflow state
  const [currentStep, setCurrentStep] = useState<WorkflowStep>('sending-to-ai');
  const [progress, setProgress] = useState(0);
  
  // Data state
  const [outline, setOutline] = useState<OutlineItem[]>([]);
  const [scenePrompts, setScenePrompts] = useState<SceneData[]>([]);
  const [characters, setCharacters] = useState<Character[]>([]);
  const [editingOutlineItem, setEditingOutlineItem] = useState<OutlineItem | null>(null);
  
  // Enhanced prompt generated by AI
  const [enhancedPrompt, setEnhancedPrompt] = useState('');
  
  // Generate story outline using OpenAI (simulated for now)
  const generateOutline = async () => {
    setCurrentStep('generating-outline');
    setProgress(10);
    
    try {
      setProgress(30);
      // In a real implementation, this would be an actual API call:
      // const response = await fetch('/api/ai/generate-outline', {
      //   method: 'POST',
      //   headers: { 'Content-Type': 'application/json' },
      //   body: JSON.stringify({
      //     prompt: initialPrompt,
      //     systemMessage: "You are an expert storyteller...",
      //   })
      // });
      // const data = await response.json();
      
      // For now, simulate the AI response
      await new Promise(resolve => setTimeout(resolve, 3000));
      
      // Sample outline data (in a real implementation, this would be parsed from the AI response)
      const sampleOutline: OutlineItem[] = [
        {
          id: 'outline1',
          title: 'Introduction to the World',
          description: 'Establish the dystopian setting and introduce the reluctant protagonist who is living a mundane life, unaware of the adventure ahead.',
          order: 1
        },
        {
          id: 'outline2',
          title: 'Discovery of Technology',
          description: 'The protagonist stumbles upon a piece of forgotten advanced technology that seems to have capabilities beyond their understanding.',
          order: 2
        },
        {
          id: 'outline3',
          title: 'Pursuit Begins',
          description: 'Powerful forces become aware of the discovery and begin hunting the protagonist to retrieve the technology.',
          order: 3
        },
        {
          id: 'outline4',
          title: 'Meeting the Ally',
          description: 'The protagonist meets a knowledgeable ally who reveals the true significance of the discovered technology.',
          order: 4
        },
        {
          id: 'outline5',
          title: 'Understanding the Power',
          description: 'Through trials and experimentation, the protagonist begins to understand how to control the technology and glimpses its potential.',
          order: 5
        },
        {
          id: 'outline6',
          title: 'Confrontation with Antagonist',
          description: 'The main antagonist corners the protagonist, leading to a direct confrontation where the technology is nearly lost.',
          order: 6
        },
        {
          id: 'outline7',
          title: 'Mastering the Technology',
          description: 'After escaping, the protagonist fully embraces their role and masters the technology, preparing for the final conflict.',
          order: 7
        },
        {
          id: 'outline8',
          title: 'Final Battle',
          description: 'A climactic confrontation where the protagonist uses the technology to defeat the antagonist and change the dystopian world.',
          order: 8
        },
        {
          id: 'outline9',
          title: 'New Beginning',
          description: 'Epilogue showing how the protagonist\'s actions have begun to transform society, with hints at future adventures.',
          order: 9
        }
      ];
      
      const sampleCharacters: Character[] = [
        {
          id: 'char1',
          name: 'Alex Mercer',
          description: 'A disillusioned tech worker with a mysterious past who discovers the advanced technology.',
          role: 'protagonist'
        },
        {
          id: 'char2',
          name: 'Director Voss',
          description: 'The cold, calculating head of the corporation that created the technology, determined to reclaim it at any cost.',
          role: 'antagonist'
        },
        {
          id: 'char3',
          name: 'Dr. Eliza Chen',
          description: 'A brilliant scientist who helps Alex understand the technology and its origins.',
          role: 'ally'
        }
      ];
      
      setOutline(sampleOutline);
      setCharacters(sampleCharacters);
      setProgress(100);
      
      // Move to the review step
      setCurrentStep('reviewing-outline');
      
    } catch (error) {
      console.error('Error generating outline:', error);
      // Handle error state
    }
  };
  
  // Generate scene prompts based on approved outline
  const generateScenePrompts = async () => {
    setCurrentStep('generating-scene-prompts');
    setProgress(0);
    
    try {
      const totalScenes = outline.length;
      const scenePromptResults: SceneData[] = [];
      
      // Process each outline item to create scene prompts
      for (let i = 0; i < outline.length; i++) {
        const outlineItem = outline[i];
        
        setProgress(Math.round((i / totalScenes) * 100));
        
        // In a real implementation, this would be an API call to generate visual prompts
        // const response = await fetch('/api/ai/generate-scene-prompt', {
        //   method: 'POST',
        //   headers: { 'Content-Type': 'application/json' },
        //   body: JSON.stringify({
        //     outlineItem,
        //     characters,
        //     style: "cinematic, detailed"
        //   })
        // });
        // const sceneData = await response.json();
        
        // Simulate API call
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // Sample scene data (in a real implementation, this would come from the AI)
        const sceneData: SceneData = {
          id: `scene${i+1}`,
          outlineItemId: outlineItem.id,
          title: outlineItem.title,
          description: outlineItem.description,
          visualPrompt: `A cinematic shot of ${outlineItem.title.toLowerCase()} with dramatic lighting and detailed environment.`,
          characters: i === 0 ? ['char1'] : i === 1 ? ['char1', 'char3'] : ['char1', 'char2', 'char3'],
          settings: `Dystopian cityscape with advanced technology elements`,
          visualStyle: `High contrast lighting with neon accents`,
          cameraAngles: [`Medium shot`, `Low angle`],
          lighting: `Moody backlighting with atmospheric haze`
        };
        
        // For specific scenes, add more detailed prompts (in a real implementation, these would come from the AI)
        if (i === 0) {
          sceneData.visualPrompt = `A lonely figure stands on a rooftop overlooking a vast dystopian cityscape at dusk. Massive corporate towers loom in the distance with holographic advertisements illuminating the smog-filled sky. The protagonist's silhouette is lit by the glow of neon signs, creating a striking contrast against the decaying urban environment. Camera angle: wide establishing shot with dramatic perspective. Lighting: blue-hour ambient light mixed with harsh neon highlights.`;
        } else if (i === outline.length - 1) {
          sceneData.visualPrompt = `Dawn breaks over the transformed cityscape, with nature reclaiming parts of the urban environment. The protagonist stands confidently in the foreground, the advanced technology now seamlessly integrated with their appearance. Beams of golden sunlight pierce through clouds, symbolizing hope. In the background, people emerge from their homes, looking upward with expressions of wonder. Camera angle: wide shot slowly pulling back. Lighting: warm, hopeful golden hour lighting with lens flares.`;
        }
        
        scenePromptResults.push(sceneData);
      }
      
      setScenePrompts(scenePromptResults);
      setProgress(100);
      setCurrentStep('reviewing-scene-prompts');
      
    } catch (error) {
      console.error('Error generating scene prompts:', error);
      // Handle error state
    }
  };
  
  // Start the workflow when component mounts
  useEffect(() => {
    const startWorkflow = async () => {
      setProgress(0);
      
      // First, enhance the initial prompt
      try {
        // In a real implementation:
        // const response = await fetch('/api/ai/enhance-prompt', {
        //   method: 'POST',
        //   headers: { 'Content-Type': 'application/json' },
        //   body: JSON.stringify({ prompt: initialPrompt })
        // });
        // const data = await response.json();
        
        // Simulate API call
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        // Sample enhanced prompt
        const enhancedPromptText = `In a sprawling dystopian metropolis where corporate power has replaced government, a reluctant tech worker discovers an abandoned prototype device with capabilities beyond current technology. As the device's true function becomes clear—the ability to manipulate the digital infrastructure that controls every aspect of society—powerful forces begin hunting the protagonist. Thrust into a dangerous game of cat and mouse, they must master this revolutionary technology while evading those who would use it to solidify their control, ultimately deciding whether to use it for personal gain or to liberate a society unaware of its own imprisonment.`;
        
        setEnhancedPrompt(enhancedPromptText);
        setProgress(100);
        
        // Move to outline generation
        await generateOutline();
        
      } catch (error) {
        console.error('Error enhancing prompt:', error);
        // Handle error state
      }
    };
    
    startWorkflow();
  }, [initialPrompt]);
  
  // Regenerate the outline
  const handleRegenerateOutline = async () => {
    setOutline([]);
    setCurrentStep('generating-outline');
    setProgress(0);
    await generateOutline();
  };
  
  // Save outline edits
  const handleSaveOutlineEdit = () => {
    if (editingOutlineItem) {
      setOutline(outline.map(item => 
        item.id === editingOutlineItem.id ? editingOutlineItem : item
      ));
      setEditingOutlineItem(null);
    }
  };
  
  // Approve outline and move to scene prompt generation
  const handleApproveOutline = () => {
    generateScenePrompts();
  };
  
  // Proceed to editor with generated scene data
  const handleProceedToEditor = () => {
    onComplete(scenePrompts);
  };
  
  // Reorder outline items
  const handleMoveOutlineItem = (id: string, direction: 'up' | 'down') => {
    const currentIndex = outline.findIndex(item => item.id === id);
    if (
      (direction === 'up' && currentIndex === 0) || 
      (direction === 'down' && currentIndex === outline.length - 1)
    ) {
      return; // Can't move further
    }
    
    const newIndex = direction === 'up' ? currentIndex - 1 : currentIndex + 1;
    const newOutline = [...outline];
    const [movedItem] = newOutline.splice(currentIndex, 1);
    newOutline.splice(newIndex, 0, movedItem);
    
    // Update order numbers
    const reorderedOutline = newOutline.map((item, index) => ({
      ...item,
      order: index + 1
    }));
    
    setOutline(reorderedOutline);
  };
  
  // Render different content based on current step
  const renderContent = () => {
    switch (currentStep) {
      case 'sending-to-ai':
      case 'generating-outline':
        return (
          <div className="text-center">
            <h3 className="text-lg font-semibold text-white mb-4">
              {currentStep === 'sending-to-ai' ? 'Sending to OpenAI GPT-4o...' : 'Generating Story Outline...'}
            </h3>
            <p className="text-white/80 mb-6">
              Our AI is analyzing your prompt and crafting a detailed story structure...
            </p>
            <div className="w-full h-2 bg-white/10 rounded-full mb-2">
              <div 
                className="h-2 bg-blue-600 rounded-full transition-all duration-500" 
                style={{ width: `${progress}%` }}
              ></div>
            </div>
            
            {enhancedPrompt && (
              <EnhancedGlassMorphicContainerV2 className="mt-6 text-left" padding="small">
                <h4 className="text-md font-medium text-white mb-2">Enhanced Prompt:</h4>
                <p className="text-white/90">{enhancedPrompt}</p>
              </EnhancedGlassMorphicContainerV2>
            )}
          </div>
        );
        
      case 'reviewing-outline':
      case 'editing-outline':
        return (
          <div>
            <div className="flex justify-between items-center mb-4">
              <h3 className="text-lg font-semibold text-white">Story Outline</h3>
              <div className="space-x-2">
                <button
                  onClick={handleRegenerateOutline}
                  className="px-3 py-1 bg-custom-gray-40 text-white rounded-md text-sm border border-white/10 hover:bg-custom-gray-50"
                >
                  Regenerate
                </button>
                <button
                  onClick={handleApproveOutline}
                  className="px-3 py-1 bg-blue-600 text-white rounded-md text-sm hover:bg-blue-700"
                >
                  Approve & Continue
                </button>
              </div>
            </div>
            
            <p className="text-white/80 mb-4 text-sm">
              Review the generated outline below. You can edit any section by clicking on it, or reorder sections using the arrows.
            </p>
            
            <div className="space-y-3 mb-6">
              {outline.map((item) => (
                <EnhancedGlassMorphicContainerV2 
                  key={item.id}
                  className="relative" 
                  padding="small"
                >
                  {editingOutlineItem && editingOutlineItem.id === item.id ? (
                    // Edit mode
                    <div className="space-y-2">
                      <input
                        value={editingOutlineItem.title}
                        onChange={(e) => setEditingOutlineItem({
                          ...editingOutlineItem,
                          title: e.target.value
                        })}
                        className="w-full p-2 bg-custom-gray-30 border border-white/30 rounded-md text-sm text-white"
                      />
                      <textarea
                        value={editingOutlineItem.description}
                        onChange={(e) => setEditingOutlineItem({
                          ...editingOutlineItem,
                          description: e.target.value
                        })}
                        rows={3}
                        className="w-full p-2 bg-custom-gray-30 border border-white/30 rounded-md text-sm text-white"
                      />
                      <div className="flex justify-end space-x-2">
                        <button
                          onClick={() => setEditingOutlineItem(null)}
                          className="px-3 py-1 bg-custom-gray-40 text-white rounded-md text-sm"
                        >
                          Cancel
                        </button>
                        <button
                          onClick={handleSaveOutlineEdit}
                          className="px-3 py-1 bg-blue-600 text-white rounded-md text-sm"
                        >
                          Save
                        </button>
                      </div>
                    </div>
                  ) : (
                    // View mode
                    <div 
                      className="cursor-pointer"
                      onClick={() => setEditingOutlineItem(item)}
                    >
                      <div className="flex justify-between">
                        <h4 className="text-white font-medium">{item.order}. {item.title}</h4>
                        <div className="flex space-x-1">
                          <button
                            onClick={(e) => {
                              e.stopPropagation();
                              handleMoveOutlineItem(item.id, 'up');
                            }}
                            className="text-white/60 hover:text-white/90"
                            disabled={item.order === 1}
                          >
                            ↑
                          </button>
                          <button
                            onClick={(e) => {
                              e.stopPropagation();
                              handleMoveOutlineItem(item.id, 'down');
                            }}
                            className="text-white/60 hover:text-white/90"
                            disabled={item.order === outline.length}
                          >
                            ↓
                          </button>
                        </div>
                      </div>
                      <p className="text-white/80 text-sm mt-1">{item.description}</p>
                    </div>
                  )}
                </EnhancedGlassMorphicContainerV2>
              ))}
            </div>
            
            <EnhancedGlassMorphicContainerV2 className="mb-4" padding="small">
              <h4 className="text-md font-medium text-white mb-2">Characters</h4>
              <div className="grid grid-cols-1 gap-3 sm:grid-cols-3">
                {characters.map(character => (
                  <div key={character.id} className="p-2 border border-white/10 rounded-md">
                    <p className="text-white font-medium">{character.name}</p>
                    <p className="text-white/70 text-xs italic">{character.role}</p>
                    <p className="text-white/80 text-sm mt-1">{character.description}</p>
                  </div>
                ))}
              </div>
            </EnhancedGlassMorphicContainerV2>
          </div>
        );
        
      case 'generating-scene-prompts':
        return (
          <div className="text-center">
            <h3 className="text-lg font-semibold text-white mb-4">Generating Scene Prompts...</h3>
            <p className="text-white/80 mb-6">
              Creating visual descriptions for each scene in your story...
            </p>
            <div className="w-full h-2 bg-white/10 rounded-full mb-2">
              <div 
                className="h-2 bg-blue-600 rounded-full transition-all duration-500" 
                style={{ width: `${progress}%` }}
              ></div>
            </div>
            <p className="text-white/60 text-sm">
              Processing scene {Math.ceil((outline.length * progress) / 100)} of {outline.length}
            </p>
          </div>
        );
        
      case 'reviewing-scene-prompts':
      case 'generating-images':
      case 'complete':
        return (
          <div>
            <div className="flex justify-between items-center mb-4">
              <h3 className="text-lg font-semibold text-white">Scene Prompts</h3>
              <button
                onClick={handleProceedToEditor}
                className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700"
              >
                Continue to Editor
              </button>
            </div>
            
            <p className="text-white/80 mb-4 text-sm">
              Review the generated scene prompts below. These will be used to generate images in the editor.
            </p>
            
            <div className="space-y-4">
              {scenePrompts.map((scene, index) => (
                <EnhancedGlassMorphicContainerV2 key={scene.id} padding="small">
                  <h4 className="text-white font-medium">{index + 1}. {scene.title}</h4>
                  <p className="text-white/80 text-sm mb-2">{scene.description}</p>
                  
                  <div className="mt-3 pt-3 border-t border-white/10">
                    <p className="text-white/90 text-sm font-medium">Visual Prompt:</p>
                    <p className="text-white/80 text-sm italic">{scene.visualPrompt}</p>
                  </div>
                  
                  <div className="mt-3 grid grid-cols-2 gap-2 text-xs text-white/70">
                    <div>
                      <span className="font-medium">Setting:</span> {scene.settings}
                    </div>
                    <div>
                      <span className="font-medium">Style:</span> {scene.visualStyle}
                    </div>
                    <div>
                      <span className="font-medium">Lighting:</span> {scene.lighting}
                    </div>
                    <div>
                      <span className="font-medium">Characters:</span> {scene.characters.map(id => 
                        characters.find(c => c.id === id)?.name
                      ).join(', ')}
                    </div>
                  </div>
                </EnhancedGlassMorphicContainerV2>
              ))}
            </div>
          </div>
        );
    }
  };
  
  return (
    <div className="max-w-4xl mx-auto">
      <EnhancedGlassMorphicContainerV2 className="p-6">
        <h2 className="text-2xl font-bold text-white mb-6">AI Movie Planning</h2>
        {renderContent()}
      </EnhancedGlassMorphicContainerV2>
    </div>
  );
};

export default EnhancedPromptWorkflow;